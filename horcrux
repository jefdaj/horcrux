#!/usr/bin/env python2

# TODO make permissions accessible to non-root user
# TODO if it exists, pick up HORCRUX_KEY_DIR

from docopt     import docopt
from glob       import glob
from gnupg      import GPG
from os         import makedirs
from os.path    import join, exists, splitext, abspath, dirname, basename
from re         import match
from subprocess import check_call, check_output, Popen, PIPE
from sys        import argv
from tempfile   import mktemp, mkdtemp

#########
# setup #
#########

def create_password(nchars, verbose):
    if verbose:
        print "generating a master password, which won't be saved anywhere"
    cmd = ['pwgen', '--secure', str(nchars), '1']
    return check_output(cmd).rstrip('\n') # remove trailing newline

def create_shares(gpg, passwd, threshold, nshares, output_dir, verbose):
    if verbose:
        msg = 'splitting the password into %d shares, any %d of which can reconstruct it'
        print msg % (nshares, threshold)
    # TODO -w token? -x (hex mode)? small or variable-length strings instead of 1024?
    cmd = ['ssss-split', '-t', str(threshold), '-n', str(nshares), '-s', '1024']
    proc = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    (out, err) = proc.communicate(passwd)
    shares = out.split('\n')[1:-1]
    assert len(shares) == nshares
    for n in range(1, nshares+1):
        path = join(output_dir, 'share-%.2d.key' % n)
        if verbose:
            print 'writing share %d to %s' % (n, path)
        share = shares[n-1]
        # assert len(share) == 258 # TODO not needed if we test round trip later?
        with open(path, 'w') as f:
            f.write('%s\n' % share)
        # TODO do I need to take a hash first and sign that or something?
        sign_file(gpg, 'verify', path, verbose)

def create_keyring(home, verbose):
    if verbose:
        print 'creating temporary gpg instance with homedir %s' % home
    with open(join(home, 'gpg-agent.conf'), 'w') as f:
        f.write('allow-loopback-pinentry\n')
    return GPG(gnupghome=home, use_agent=False) # TODO use_agent? keyring?

def create_keypair(gpg, pubname, privname, passwd, output_dir, verbose):
    pubfile   = join(output_dir, pubname  + '.key')
    privfile  = join(output_dir, privname + '.key')
    bothnames = pubname + '/' + privname
    if verbose:
        print 'creating %s keypair' % bothnames
    params = {
        'key_type'   : 'RSA',
        'key_length' : 4096,
        'name_real'  : bothnames,
        'name_email' : privname # TODO gotta be a better way right? key id?
    }
    if passwd:
        params['passphrase'] = passwd
    gpg.gen_key(gpg.gen_key_input(**params))
    [pubname, privname] = bothnames.split('/')
    pubfile  = join(output_dir, pubname  + '.key')
    privfile = join(output_dir, privname + '.key')
    if verbose:
        print 'writing %s' % pubfile
    with open(pubfile, 'w') as f:
        f.write(gpg.export_keys(pubname, False))
    if verbose:
        print 'writing %s' % privfile
    with open(privfile, 'w') as f:
        f.write(gpg.export_keys(privname, True))

def setup(gpg, threshold, nshares, output_dir, verbose=False):
    passwd = create_password(128, verbose)
    create_keypair(gpg, 'encrypt', 'decrypt', passwd, output_dir, verbose)
    create_keypair(gpg, 'verify' , 'sign'   , None  , output_dir, verbose)
    create_shares(gpg, passwd, threshold, nshares, output_dir, verbose)

########
# sign #
########

def import_key(gpg, filename, verbose, passwd=None):
    if verbose:
        print 'importing gpg key %s' % filename
    with open(filename, 'rb') as f:
        gpg.import_keys(f.read())

def sign_file(gpg, keyname, file_to_sign, verbose):
    outfile = file_to_sign + '.sig' # TODO take an optional argument for this?
    if verbose:
        print 'signing %s with "%s" key (output in %s)' % (file_to_sign, keyname, outfile)
    with open(file_to_sign, 'r') as f:
        signed = gpg.sign_file(f, keyid=keyname, detach=True)
    with open(outfile, 'wb') as f:
        f.write(signed.data)

def sign(gpg, sign_key, file_to_sign, verbose):
    import_key(gpg, sign_key, verbose)
    sign_file(gpg, 'verify', file_to_sign, verbose)

###########
# encrypt #
###########

def encrypt_file(gpg, recipient, before_path, after_path, verbose):
    if verbose:
        print 'encrypting %s to "%s" (output in %s)' \
               % (before_path, recipient, after_path)
    with open(before_path, 'rb') as f:
        status = gpg.encrypt_file(f, recipients=[recipient],
                                  output=after_path, always_trust=True)
    if not status.ok:
        print status.status
        print status.stderr
        raise SystemExit(1)

def encrypt(gpg, encrypt_key, sign_key, before, after, verbose):
    import_key(gpg, encrypt_key, verbose)
    import_key(gpg, sign_key  , verbose)
    encrypt_file(gpg, 'encrypt', before, after, verbose)
    sign_file(gpg, 'verify', after, verbose)

##########
# verify #
##########

def verify(gpg, verify_key, signed_file, verbose):
    import_key(gpg, verify_key, verbose)
    if verbose:
        print 'verifying %s with %s' % (signed_file, verify_key)
    sig_file = signed_file + '.sig'
    asc_file = signed_file + '.asc'
    if exists(sig_file):
        signature = sig_file
    elif exists(asc_file):
        signature = asc_file
    else:
        raise SystemExit('error! missing signature for %s' % signed_file)
    with open(signature, 'rb') as f:
        success = gpg.verify_file(f, data_filename=signed_file)
    if success:
        print 'verified signature for %s' % basename(signed_file)
    else:
        raise SystemExit('error! failed to verify %s' % basename(signed_file))

###########
# decrypt #
###########

def recreate_password(threshold, share_paths, stego_pass, verbose):
    if verbose:
        print 'trying to reconstruct password from %d shares...' % threshold,
    cmd = ['ssss-combine', '-t', str(threshold)]
    shares = '' # newline-separated list of shares
    for path in share_paths:
        with open(path, 'r') as f:
            shares += f.read()
    proc = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    (out, err) = proc.communicate(shares)
    passwd = err.split(':')[1].strip()
    if len(passwd) == 128:
        if verbose:
            print 'success!'
    else:
        if verbose:
            print 'fail'
        raise SystemExit(1)
    return passwd

def auto_recreate_password(share_paths, stego_pass, verbose):
    # TODO how to avoid failure if duplicates? (.key and .jpeg for example)
    for n in range(1, len(share_paths)+1):
        try:
            return recreate_password(n, share_paths[:n], stego_pass, verbose)
        except:
            # raise
            continue
    print 'failed to reconstruct password'
    raise SystemExit(1)

def untar(tarfile, verbose):
    outdir = tarfile.split('.tar')[0]
    print 'extracting %s to %s:' % (basename(tarfile), basename(outdir))
    cmd = ['tar', 'xv', '-f', tarfile, '--one-top-level=%s' % outdir]
    check_call(cmd)

def decrypt_file(gpg, decrypt_key, secretfile, password, outfile, verbose):
    if verbose:
        msg = 'decrypting %s with %s and the password (output in %s)'
        print msg % (basename(secretfile),
                     basename(decrypt_key),
                     basename(outfile))
    import_key(gpg, decrypt_key, verbose)
    with open(secretfile, 'rb') as f:
        status = gpg.decrypt_file(f, passphrase=password, output=outfile)
    if not status.ok:
        print status.status
        print status.stderr
        raise SystemExit(1)
    print 'decrypted %s' % basename(outfile)
    if outfile.endswith('.tar'):
        untar(outfile, verbose)

def decrypt(gpg, decrypt_key, secretfile, outfile, passwd, verbose, verify_key=None):
    if verify_key:
        # if verification of some files fails, we still want to attempt decryption
        try:
            verify(gpg, verify_key, secretfile, verbose)
        except:
            pass
    decrypt_file(gpg, decrypt_key, secretfile, passwd, outfile, verbose)

########
# hide #
########

def sha256sum(filename, verbose):
    if verbose:
        print 'calculating sha256sum of %s' % filename
    cmd = ['sha256sum', filename]
    sha = check_output(cmd).split()[0]
    return sha

def hide(file_to_hide, cover_file, outfile, passphrase, verbose):
    if verbose:
        print 'hiding %s in %s (output in %s)' % (file_to_hide, cover_file, outfile)
    # TODO quote passphrase?
    cmd = ['steghide', 'embed', '-ef', file_to_hide, '-cf', cover_file,
           '-sf', outfile, '-p', passphrase]
    check_call(cmd)

##########
# unhide #
##########

def unhide(stego_file, outfile, passphrase, verbose):
    if verbose:
        print 'extracting %s to %s' % (basename(stego_file), outfile)
    cmd = ['steghide', 'extract', '-sf', stego_file,
           '-xf', outfile, '-p', passphrase]
    if not verbose:
        cmd.append('--quiet')
    check_call(cmd)

def unhide_any(gpg, shares, passphrase, verbose):
    # unhides and hidden shares and gives back a key-only list
    regular  = [s for s in shares if     s.endswith('.key')]
    hidden   = [s for s in shares if not s.endswith('.key')]
    unhidden = []
    for n in range(len(hidden)):
        stego_file = hidden[n]
        tmpfile    = mktemp(suffix='.key')
        unhide(stego_file, tmpfile, passphrase, verbose)
        unhidden.append(tmpfile)
    return sorted(regular) + sorted(unhidden)

###############
# auto-verify #
###############

def find_files(working_dir):
    # TODO be more intelligent about names? this fails if they're at all tricky
    if not working_dir:
        working_dir = '.'
    files = glob(join(working_dir, '*'))
    filters = {
        'secret'      : '.*\\.gpg$',
        'verify_key'  : '.*verify\\.key$',
        'decrypt_key' : '.*decrypt\\.key$',
        'shares'      : '.*share.*\\.key$',
        'signatures'  : '.*\\.(sig|asc)$'
    }
    matches = {}
    for key in filters:
        matches[key] = sorted(f for f in files if match(filters[key], f))
    matches['shares'] = sorted(s for s in matches['shares'] if not s.endswith('.sig'))
    matches['signed'] = sorted(splitext(s)[0] for s in matches['signatures'])
    return matches

def auto_verify(gpg, working_dir, verbose):
    files = find_files(working_dir)
    if len(files['verify_key']) == 0: raise SystemExit('verify key not found')
    if len(files['verify_key']) >  1: raise SystemExit('found multiple verify keys')
    if len(files['secret'    ]) == 0: print 'secret file not found'
    key = files['verify_key'][0]
    signed_files = sorted(set(files['secret'] + files['shares'] + files['signed']))
    for signed_file in signed_files:
        verify(gpg, key, signed_file, verbose)

################
# auto-decrypt #
################

def auto_decrypt(gpg, working_dir, verbose):
    # if verification of some files fails, we still want to attempt decryption
    try:
        auto_verify(gpg, working_dir, verbose)
    except:
        pass
    files = find_files(working_dir)
    shares  = sorted(files['shares'])
    secrets = sorted(files['secret']) # TODO catch misc filenames here
    if len(files['decrypt_key']) == 0: raise SystemExit('decrypt key not found')
    if len(files['decrypt_key'])  > 1: raise SystemExit('multiple decrypt keys found')
    if len(shares ) == 0: raise SystemExit('no password shares found')
    if len(secrets) == 0: raise SystemExit('no secret files found')
    decrypt_key = files['decrypt_key'][0]
    stego_pass  = sha256sum(decrypt_key, verbose)
    shares      = unhide_any(gpg, shares, stego_pass, verbose)
    master_pass = auto_recreate_password(shares, stego_pass, verbose)
    for secret in secrets:
        outfile = splitext(secret)[0]
        decrypt(gpg, decrypt_key, secret, outfile, master_pass, verbose)

########
# main #
########

def main(args):
    verbose = bool(args['--verbose'])
    # with tempfile.TemporaryDirectory() as home:
    home = mkdtemp() # TODO use a context or handle exceptions
    gpg = create_keyring(home, verbose)

    if args['setup']:
        output_dir = args['<output-dir>']
        if not output_dir:
            output_dir = '.'
        if not exists(output_dir):
            makedirs(output_dir)
        threshold = int(args['<threshold>'])
        shares    = int(args['<shares>'])
        setup(gpg, threshold, shares, output_dir, verbose)

    elif args['decrypt']:
        decrypt_key = args['<decrypt-key>']
        verify_key  = args['<verify-key>']
        secret      = args['<locked-file>']
        outfile     = args['<output-path>']
        shares      = args['<share>']
        stego_pass  = sha256sum(decrypt_key, verbose)
        shares      = unhide_any(gpg, shares, stego_pass, verbose)
        master_pass = auto_recreate_password(shares, stego_pass, verbose)
        decrypt(gpg, decrypt_key, secret, outfile, master_pass, verbose, verify_key)

    elif args['sign']:
        sign_key     = args['<sign-key>']
        file_to_sign = args['<file-to-sign>']
        sign(gpg, sign_key, file_to_sign, verbose)

    elif args['encrypt']:
        sign_key    = args['<sign-key>']
        encrypt_key = args['<encrypt-key>']
        before      = args['<file-to-encrypt>']
        after       = args['<output-path>']
        encrypt(gpg, encrypt_key, sign_key, before, after, verbose)

    elif args['verify']:
        verify_key = args['<verify-key>']
        secret     = args['<locked-file>']
        verify(gpg, verify_key, secret, verbose)

    elif args['hide']:
        decrypt_key  = args['<decrypt-key>']
        file_to_hide = args['<file-to-hide>']
        cover_file   = args['<cover-file>']
        outfile      = args['<output-path>']
        stego_pass   = sha256sum(decrypt_key, verbose)
        hide(file_to_hide, cover_file, outfile, stego_pass, verbose)

    elif args['unhide']:
        decrypt_key = args['<decrypt-key>']
        stego_file  = args['<stego-file>']
        outfile     = args['<output-path>']
        stego_pass  = sha256sum(decrypt_key, verbose)
        unhide(stego_file, outfile, stego_pass, verbose)

    elif args['autoverify']:
        working_dir = args['<working-dir>']
        auto_verify(gpg, working_dir, verbose)

    elif args['autodecrypt']:
        working_dir = args['<working-dir>']
        auto_decrypt(gpg, working_dir, verbose)

if __name__ == '__main__':
    with open(join(dirname(__file__), 'usage.txt'), 'r') as f:
        args = docopt(f.read())
    main(args)
